<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ITパス 練習（100問・自動整列＆ボタン白）</title>
<style>
  :root{
    --bg:#0f1220;
    --panel:#151935;
    --muted:#a7b1c2;
    --text:#ffffff;
    --accent:#5aa9ff;
    --correct:#16c47f;
    --wrong:#ff5a7d;
    --btn:#23284d;
    --btnHover:#2e3566;
    --btnActive:#3a4385;
  }
  html,body{height:100%}
  body{
    margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Noto Sans JP",sans-serif;
    letter-spacing:.02em;
  }
  header{
    display:flex;gap:12px;align-items:center;justify-content:space-between;
    padding:14px 16px;background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,0));
    position:sticky;top:0;backdrop-filter:blur(6px);z-index:10;
    border-bottom:1px solid rgba(255,255,255,.08);
  }
  .brand{font-weight:700}
  .meta{font-size:.9rem;color:var(--muted)}
  .wrap{max-width:980px;margin:0 auto;padding:20px}
  .card{
    background:var(--panel);border:1px solid rgba(255,255,255,.08);
    border-radius:16px;padding:18px 16px;box-shadow:0 10px 30px rgba(0,0,0,.25)
  }
  .progress{
    height:10px;background:#0a0d1a;border-radius:999px;overflow:hidden;border:1px solid rgba(255,255,255,.08)
  }
  .bar{height:100%;width:0;background:linear-gradient(90deg,var(--accent),#8fd1ff)}
  .qno{font-weight:700;margin-bottom:6px}
  .qtext{font-size:1.05rem;line-height:1.7}
  .choices{display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-top:16px}
  button.opt{
    all:unset;box-sizing:border-box;display:flex;gap:12px;align-items:center;cursor:pointer;
    background:var(--btn);border:1px solid rgba(255,255,255,.1);border-radius:12px;padding:14px 12px;
    transition:.15s transform ease,.15s background ease,.15s border-color ease;
    /* ここが肝：文字色を常に白で固定 */
    color:var(--text) !important;
  }
  button.opt:hover{background:var(--btnHover);transform:translateY(-1px)}
  button.opt:active{background:var(--btnActive);transform:translateY(0)}
  button.opt[disabled]{opacity:.75;cursor:not-allowed}
  .opt .pill{
    width:28px;height:28px;display:grid;place-items:center;border-radius:999px;
    border:1px solid rgba(255,255,255,.18);flex:0 0 auto;
    color:var(--text) !important;background:rgba(255,255,255,.06);
    font-weight:700
  }
  .opt.correct{border-color:rgba(22,196,127,.9);box-shadow:0 0 0 3px rgba(22,196,127,.2) inset}
  .opt.wrong{border-color:rgba(255,90,125,.9);box-shadow:0 0 0 3px rgba(255,90,125,.15) inset}
  .ex{margin-top:14px;color:var(--muted);font-size:.95rem}
  .controls{display:flex;gap:10px;margin-top:16px}
  .btn{
    all:unset;cursor:pointer;background:#0d6efd;border:1px solid rgba(255,255,255,.18);
    color:#fff;padding:10px 14px;border-radius:10px;font-weight:600
  }
  .btn.secondary{background:#2d335f}
  .pillStat{font-size:.85rem;color:var(--muted)}
  details.nav{margin:12px 0}
  details.nav summary{cursor:pointer;padding:10px 12px;background:#1a2044;border-radius:10px;border:1px solid rgba(255,255,255,.08)}
  .list{display:flex;flex-wrap:wrap;gap:8px;margin-top:10px}
  .tag{padding:6px 10px;border-radius:999px;background:#23284d;color:#fff;border:1px solid rgba(255,255,255,.08);cursor:pointer}
  .small{font-size:.85rem;color:var(--muted)}
  pre.small{white-space:pre-wrap;word-break:break-all;background:#0b0e1f;padding:12px;border-radius:8px;border:1px solid rgba(255,255,255,.08)}
</style>
</head>
<body>
  <header>
    <div class="brand">ITパス 練習</div>
    <div class="meta"><span id="countMeta">読み込み中…</span></div>
  </header>

  <div class="wrap">
    <div class="card" id="intro">
      <p style="margin-top:0">下の <b>RAWデータ</b> に、あなたの問題データ（壊れていてもOK）を丸ごと貼ってください。スクリプトが自動で：</p>
      <ul>
        <li>壊れたネストや余計なブロックを <b>除去</b></li>
        <li>重複を <b>番号でデデュープ</b></li>
        <li><b>1 → 100</b> に整列</li>
      </ul>
      <p class="small">※ すでにサンプルとして 51〜100 と 1〜50 が混在した壊れデータを入れてあります。何も触らずそのままでも 100問に復元されて開始できます。</p>
      <div class="controls">
        <button class="btn" id="startBtn">全100問で開始</button>
        <button class="btn secondary" id="exportBtn">整形JSONを表示</button>
      </div>
      <details class="nav" style="margin-top:10px">
        <summary>復元後の問題一覧（クリックでジャンプ）</summary>
        <div class="list" id="jumpList"></div>
      </details>
    </div>

    <div class="card" id="quiz" style="display:none">
      <div class="qno"><span id="qnumber">Q1/100</span> <span class="pillStat" id="stat"></span></div>
      <div class="qtext" id="qtext"></div>
      <div class="choices" id="choices"></div>
      <div class="ex" id="explain" style="display:none"></div>
      <div class="controls">
        <button class="btn secondary" id="prevBtn">前へ</button>
        <button class="btn" id="nextBtn">次へ</button>
      </div>
      <div style="margin-top:16px" class="progress"><div class="bar" id="bar"></div></div>
    </div>

    <div class="card" id="result" style="display:none">
      <h3 style="margin-top:0">結果</h3>
      <p id="score"></p>
      <div class="controls">
        <button class="btn" id="retryWrong">不正解だけ復習</button>
        <button class="btn secondary" id="restart">最初から</button>
      </div>
    </div>

    <details class="nav" style="margin-top:14px">
      <summary>RAWデータ（ここに壊れたまま貼ってOK）</summary>
      <pre class="small" id="rawEcho"></pre>
    </details>

  </div>

  <!-- ここに “壊れたまま” のデータを貼ってOK。スクリプトが直します -->
  <script id="raw-data" type="application/json">
  {
    "note": "このブロックに、あなたの壊れたデータを丸ごと貼ってください。下はユーザー提供の混在サンプル（Q51..100 + 1..50 がQ88の途中にネスト）。",
    "questions_mixed": [
      { "number": 51, "question": "社内で開発及び運用を行っている経理システムの内部監査を実施するとき、システム監査人として、最も適切なものはどれか。", "choices": ["経理システムの運用担当者","経理システムの開発を担当した委託会社の従業員","経理システムの利用者である経理担当者","経理とITの知識を有する経営者直轄組織の従業員"], "answer_index": 3, "comment": "内部監査の独立性：監査対象から独立し、専門知識を持つ経営者直轄組織の従業員が適切" },
      { "number": 52, "question": "A社は会計システムの再構築…", "choices": ["A","B","C","D"], "answer_index": 0, "comment": "略（実データは貼り替えてOK）" },
      { "number": 88, "question": "無線LANのセキュリティ対策に関する記述として、適切なものはどれか。", "choices": ["SSID…","SSID…","MAC…","WPA2…"], "answer_index": 3, "comment":
        { "comment": "ITパスポート試験問題データ - 完全版100問",
          "generated_at":"2025-01-20T00:00:00.000Z",
          "total_questions":100,
          "questions":[
            { "number":1, "question":"A社がB社に…", "choices":["a","b","c","d"], "answer_index":2, "comment":"…" },
            { "number":2, "question":"従来の情報セキュリティ…", "choices":["a","b","c","d"], "answer_index":2, "comment":"…" }
            /* ……以下、1〜50 が入っているという前提の壊れ例 …… */
          ]
        }
      },
      { "number": 89, "question": "AさんはBさんから次の4種類のメッセージを受け取った。…", "choices": ["a, b, d","a, c, d","b, d","c, d"], "answer_index": 0, "comment": "…" },
      { "number": 100, "question": "データマイニングに関する記述として…", "choices": ["a","b","c","d"], "answer_index": 1, "comment": "…" }
    ]
  }
  </script>

  <script>
  // ============ サニタイザ ============

  /**
   * 1) JSONとして読めたらそのまま採用
   * 2) 失敗したら “問題オブジェクト” だけ正規表現で抽出
   * 3) 重複番号は後勝ち、1..100 に整列
   */
  function sanitizeRaw(rawText){
    // まず素直に JSON.parse を試す
    try{
      const obj = JSON.parse(rawText);
      const arr =
        Array.isArray(obj) ? obj :
        Array.isArray(obj.questions) ? obj.questions :
        Array.isArray(obj.questions_mixed) ? obj.questions_mixed : null;
      if(arr){
        return normalizeArray(arr);
      }
    }catch(e){/* fallthrough */}
    // 正規表現抽出（壊れていてもOK）
    const items = [];
    // “number”: <int> を起点にブロックをゆるく拾う
    const regex = /{[^{}]*?"number"\s*:\s*(\d+)[\s\S]*?"question"\s*:\s*"([\s\S]*?)"\s*,[\s\S]*?"choices"\s*:\s*\[([\s\S]*?)\][\s\S]*?"answer_index"\s*:\s*(\d+)[\s\S]*?"comment"\s*:\s*("([\s\S]*?)"|{[\s\S]*?}|\[.*?\]|null)[\s\S]*?}/g;
    let m;
    while((m = regex.exec(rawText))){
      const num = parseInt(m[1],10);
      const qtext = m[2].replace(/\\n/g,"\n");
      const choicesRaw = m[3];
      const choices = choicesRaw
        .split(/\s*,\s*(?=(?:[^"]*"[^"]*")*[^"]*$)/) // カンマ分割（クォート内は維持）
        .map(s => s.replace(/^\s*"?|"?\s*$/g,"").replace(/\\n/g,"\n"));
      const ans = parseInt(m[4],10);
      let comment = m[6] || ""; // オブジェクトが来たら空にしてしまう
      items.push({number:num, question:qtext, choices, answer_index:ans, comment});
    }
    return normalizeArray(items);
  }

  function normalizeArray(arr){
    // 必要キーだけ抽出＋バリデーション
    const map = new Map();
    for(const it of arr){
      const num = Number(it.number);
      if(!Number.isInteger(num)) continue;
      if(!it.question || !Array.isArray(it.choices) || it.choices.length !== 4) continue;
      const answer_index = Number(it.answer_index);
      if(!(answer_index>=0 && answer_index<4)) continue;
      const clean = {
        number:num,
        question:String(it.question),
        choices:it.choices.map(String),
        answer_index,
        comment: (typeof it.comment === "string") ? it.comment : ""
      };
      // 後勝ち（同番号が複数あれば最後のを採用）
      map.set(num, clean);
    }
    // 1..100 のみ採用して整列
    const out = [];
    for(let i=1;i<=100;i++){
      if(map.has(i)) out.push(map.get(i));
    }
    return out;
  }

  // ============ アプリ本体 ============
  const RAW_EL = document.getElementById('raw-data');
  const RAW_TEXT = RAW_EL.textContent;
  const QUESTIONS = sanitizeRaw(RAW_TEXT);

  // 検証ポイント1：100問か
  const countMeta = document.getElementById('countMeta');
  countMeta.textContent = `検出: ${QUESTIONS.length} 問`;
  document.getElementById('rawEcho').textContent = RAW_TEXT.trim();

  // ナビ作成（検証2：ジャンプできる）
  const jumpList = document.getElementById('jumpList');
  QUESTIONS.forEach(q=>{
    const a=document.createElement('button');
    a.className='tag';
    a.textContent = `Q${q.number}`;
    a.addEventListener('click',()=>{
      startQuiz();
      goToNumber(q.number);
    });
    jumpList.appendChild(a);
  });

  // UI
  const intro = document.getElementById('intro');
  const quiz = document.getElementById('quiz');
  const result = document.getElementById('result');
  const qnumber = document.getElementById('qnumber');
  const qtext = document.getElementById('qtext');
  const choices = document.getElementById('choices');
  const explain = document.getElementById('explain');
  const bar = document.getElementById('bar');
  const stat = document.getElementById('stat');

  const startBtn = document.getElementById('startBtn');
  const exportBtn = document.getElementById('exportBtn');
  const prevBtn = document.getElementById('prevBtn');
  const nextBtn = document.getElementById('nextBtn');
  const scoreEl = document.getElementById('score');
  const retryWrong = document.getElementById('retryWrong');
  const restart = document.getElementById('restart');

  let order = [];
  let idx = 0;
  let answered = new Map(); // number -> {chosen, correct}
  let wrongSet = new Set();

  function startQuiz(){
    if(QUESTIONS.length !== 100){
      alert(`注意: ${QUESTIONS.length}問しか見つかりませんでした。RAWを確認してください。`);
    }
    order = QUESTIONS.map(q=>q.number); // 1..100 順
    idx = 0; answered.clear(); wrongSet.clear();
    intro.style.display='none'; result.style.display='none'; quiz.style.display='block';
    render();
  }

  function goToNumber(n){
    const i = order.findIndex(no=>no===n);
    if(i>=0){ idx=i; render(); }
  }

  function render(){
    // 検証3：インデックス境界
    if(idx<0) idx=0;
    if(idx>=order.length){ return finish(); }
    const num = order[idx];
    const q = QUESTIONS[num-1]; // 1..100 として整列済み
    qnumber.textContent = `Q${idx+1} / ${order.length}（元番号: ${q.number}）`;
    stat.textContent = `正解 ${[...answered.values()].filter(v=>v.correct).length} / 解答 ${answered.size}`;
    qtext.textContent = q.question;
    explain.style.display='none';
    explain.textContent = q.comment ? `解説：${q.comment}` : '';

    choices.innerHTML='';
    const labels = ['あ','い','う','え'];
    q.choices.forEach((c,i)=>{
      const btn = document.createElement('button');
      btn.className='opt';
      btn.innerHTML = `<span class="pill">${labels[i]}</span> <span>${c}</span>`;
      btn.addEventListener('click', ()=>{
        lockAndJudge(i);
      }, {once:true});
      choices.appendChild(btn);
    });

    // 過去に答えていれば状態再現
    if(answered.has(q.number)){
      const prev = answered.get(q.number);
      Array.from(choices.children).forEach((b, i)=>{
        b.setAttribute('disabled','disabled');
        if(i===q.answer_index) b.classList.add('correct');
        if(i===prev.chosen && !prev.correct) b.classList.add('wrong');
      });
      explain.style.display = q.comment ? 'block' : 'none';
    }

    // 進捗（検証4）
    const prog = Math.round((idx)/order.length*100);
    bar.style.width = prog+'%';
    prevBtn.disabled = (idx===0);
    nextBtn.textContent = (idx===order.length-1) ? '結果' : '次へ';
  }

  function lockAndJudge(chosen){
    const num = order[idx];
    const q = QUESTIONS[num-1];
    const corr = (chosen===q.answer_index);
    answered.set(q.number, {chosen, correct: corr});
    if(!corr) wrongSet.add(q.number); else wrongSet.delete(q.number);
    // 視覚
    Array.from(choices.children).forEach((b, i)=>{
      b.setAttribute('disabled','disabled');
      if(i===q.answer_index) b.classList.add('correct');
      if(i===chosen && i!==q.answer_index) b.classList.add('wrong');
    });
    explain.style.display = q.comment ? 'block' : 'none';
    stat.textContent = `正解 ${[...answered.values()].filter(v=>v.correct).length} / 解答 ${answered.size}`;
  }

  function finish(){
    quiz.style.display='none'; result.style.display='block';
    const correct = [...answered.values()].filter(v=>v.correct).length;
    scoreEl.textContent = `正解 ${correct} / ${order.length}（正答率 ${(correct/order.length*100).toFixed(1)}%）`;
  }

  // イベント
  startBtn.addEventListener('click', startQuiz);
  exportBtn.addEventListener('click', ()=>{
    const data = JSON.stringify(QUESTIONS, null, 2);
    const w = window.open();
    w.document.write('<pre>'+data.replace(/[<>&]/g,s=>({'<':'&lt;','>':'&gt;','&':'&amp;'}[s]))+'</pre>');
  });
  prevBtn.addEventListener('click', ()=>{ idx--; render(); });
  nextBtn.addEventListener('click', ()=>{
    if(idx===order.length-1) finish(); else { idx++; render(); }
  });
  retryWrong.addEventListener('click', ()=>{
    if(wrongSet.size===0){ alert('不正解はありません。'); return; }
    order = [...wrongSet];
    order.sort((a,b)=>a-b);
    idx = 0; quiz.style.display='block'; result.style.display='none'; render();
  });
  restart.addEventListener('click', ()=>{
    intro.style.display='block'; quiz.style.display='none'; result.style.display='none';
  });

  // 検証5：ロード時に自動で100問検出＆ジャンプタグ生成済みか
  if(QUESTIONS.length===100){
    document.getElementById('startBtn').textContent = '全100問で開始（準備OK）';
  } else {
    document.getElementById('startBtn').textContent = `開始（${QUESTIONS.length}問 検出）`;
  }
  </script>
</body>
</html>
